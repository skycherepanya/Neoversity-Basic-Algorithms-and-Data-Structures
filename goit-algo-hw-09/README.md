# Порівняння Жадібного алгоритму та Динамічного програмування

## Опис завдання
Мета роботи — реалізувати два алгоритми для видачі решти (набір монет: 50, 25, 10, 5, 2, 1) та порівняти їх ефективність.

## Результати

### 1. Жадібний алгоритм (`find_coins_greedy`)
- **Принцип:** Завжди обирає найбільший доступний номінал монети.
- **Часова складність:** $O(N)$, де $N$ — кількість номіналів монет.
- **Продуктивність:** Миттєво працює навіть для дуже великих сум (наприклад, 10 мільярдів). Йому байдуже на розмір суми, він робить всього кілька математичних операцій ділення.

### 2. Динамічне програмування (`find_min_coins`)
- **Принцип:** Знаходить гарантовано мінімальну кількість монет, перебираючи всі варіанти складання суми.
- **Часова складність:** $O(A \cdot N)$, де $A$ — сума решти.
- **Продуктивність:** Ефективний для малих сум. При збільшенні суми час виконання зростає лінійно. Для дуже великих сум (наприклад, > 100,000) стає помітно повільнішим і потребує багато пам'яті для зберігання таблиці.

У даному домашньому завданні **Жадібний алгоритм є абсолютним переможцем** за ефективністю.